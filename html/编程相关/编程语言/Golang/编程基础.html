<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>D:\MyWiki/html/编程相关/编程语言/Golang/编程基础.html</title>
  <style>
      code{white-space: pre-wrap;}
      span.smallcaps{font-variant: small-caps;}
      span.underline{text-decoration: underline;}
      div.column{display: inline-block; vertical-align: top; width: 50%;}
  </style>
  <style>
a.sourceLine { display: inline-block; line-height: 1.25; }
a.sourceLine { pointer-events: none; color: inherit; text-decoration: inherit; }
a.sourceLine:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode { white-space: pre; position: relative; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
code.sourceCode { white-space: pre-wrap; }
a.sourceLine { text-indent: -1em; padding-left: 1em; }
}
pre.numberSource a.sourceLine
  { position: relative; left: -4em; }
pre.numberSource a.sourceLine::before
  { content: attr(title);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; pointer-events: all; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {  }
@media screen {
a.sourceLine::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
  </style>
  <link rel="stylesheet" href="misty-light-windows.css" />
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>
<h1 id="golang-编程基础">Golang 编程基础</h1>
<h4 id="注意事项">注意事项</h4>
<ul>
<li><p>只有package名称为main的包可以包含main函数</p></li>
<li><p>一个可执行程序只可以有一个main</p></li>
<li><p>可见性规则</p>
<ul>
<li>函数名首字母大写为public</li>
<li>函数名首字母小写为private</li>
</ul></li>
</ul>
<h4 id="一般的代码架构">一般的代码架构</h4>
<pre><code>```go
// 当前程序的包名，需放在所有代码之前
package main

// 导入其它的包
import std &quot;fmt&quot;  //std是重命名，类似于Python中的import fmt  as std

/*
import . &quot;fmt&quot; //省略调用，可以在程序中省略包名直接使用
*/

/*
import {
    &quot;fmt&quot;,
    &quot;os&quot;,
    &quot;time&quot;
}
*/

// 常量的定义
const PI = 3.14

// 全局变量的声明与赋值
var name = &quot;gopher&quot;

// 一般类型声明
type newType int

// 结构的声明
type gopher struct{}

// 接口的声明
type golang interface{}

// 由 main 函数作为程序入口点启动
func main() {
    std.Println(&quot;Hello world!你好，世界！&quot;)
}
```</code></pre>
<p>​</p>
<h4 id="数据类型">数据类型</h4>
<table>
<thead>
<tr class="header">
<th>数据类型</th>
<th>关键字</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>布尔</td>
<td>bool</td>
<td>长度：1字节<br />取值范围：true，false<br />不可用数字代替true和false</td>
</tr>
<tr class="even">
<td>整型</td>
<td>int/uint<a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a></td>
<td>根据运行平台为32/64位</td>
</tr>
<tr class="odd">
<td>8位整型</td>
<td>int8/uint8</td>
<td>长度：1字节<br />取值范围：-128<sub>127/0</sub>255</td>
</tr>
<tr class="even">
<td>16位整型</td>
<td>int16/uint16</td>
<td>长度：2字节</td>
</tr>
<tr class="odd">
<td>32位整型</td>
<td>int32(<em>rune</em>)/uint32</td>
<td>长度：4字节</td>
</tr>
<tr class="even">
<td>64位整型</td>
<td>int64/uint64</td>
<td>长度：8字节</td>
</tr>
<tr class="odd">
<td>浮点型</td>
<td>float32/float64</td>
<td>长度：4/8字节<br />小数位：精确到7/15位小数</td>
</tr>
<tr class="even">
<td>字节类型</td>
<td>byte(<em>uint8</em>)</td>
<td></td>
</tr>
<tr class="odd">
<td>复数</td>
<td>complex64/complex128</td>
<td>长度：8/16字节</td>
</tr>
<tr class="even">
<td>足够保存指针的32/64位整数型</td>
<td>uintptr</td>
<td></td>
</tr>
<tr class="odd">
<td>其他值类型</td>
<td>array<br />struct<br />string</td>
<td></td>
</tr>
<tr class="even">
<td>引用类型</td>
<td>slice<br />map<br />chan</td>
<td>slice 切片<br />chan 通道</td>
</tr>
<tr class="odd">
<td>接口类型</td>
<td>interface</td>
<td></td>
</tr>
<tr class="even">
<td>函数类型</td>
<td>func</td>
<td></td>
</tr>
</tbody>
</table>
<ul>
<li>类型零值：默认值
<ul>
<li>通常为0</li>
<li>bool为false</li>
<li>string为空字符串</li>
</ul></li>
<li>math 数学工具包</li>
</ul>
<h4 id="变量的声明与赋值">变量的声明与赋值</h4>
<ul>
<li><p>声明格式： var <变量名> <变量类型></p></li>
<li><p>变量赋值： <变量名> = <表达式></p></li>
<li><p>声明并赋值： var <变量名> [变量类型] = <表达式></p></li>
<li><p>简化的赋值： <变量名> := <表达式></p></li>
<li><p>不存在隐式转换，必须显示声明</p></li>
</ul>
<h4 id="常量与变量名">常量与变量名</h4>
<h5 id="常量">常量</h5>
<ul>
<li>关键字 ：const</li>
<li>若右侧为函数则必须为内置函数</li>
<li>必须为一个不被修改的值</li>
<li>一般为全大写</li>
<li>枚举
<ul>
<li>iota是常量及数据，从0开始，在每个const中从零开始递增1</li>
<li>每定义一个常量iota就增加1</li>
</ul></li>
</ul>
<h5 id="运算符">运算符</h5>
<ul>
<li><figure>
<img src="assets/1553932192292.png" alt="1553932192292" /><figcaption>1553932192292</figcaption>
</figure></li>
<li><p><code>^</code>作为二元运算符是只相同位上，两个一个为<code>1</code>一个为<code>0</code>时结果为<code>1</code></p></li>
<li><p><code>&amp;^</code>当第二个数的某一位为<code>1</code>时，将其对应位改成<code>0</code></p></li>
<li><p>在golang中，<code>&amp;</code>和<code>|</code>仅进行位运算法，<code>&amp;&amp;</code>与<code>||</code>才可以进行逻辑判断</p></li>
</ul>
<div class="sourceCode" id="cb2"><pre class="sourceCode go"><code class="sourceCode go"><a class="sourceLine" id="cb2-1" title="1"><span class="kw">const</span> (</a>
<a class="sourceLine" id="cb2-2" title="2">   B = <span class="dv">1</span> &lt;&lt; (<span class="ot">iota</span> * <span class="dv">10</span>)</a>
<a class="sourceLine" id="cb2-3" title="3">   KB</a>
<a class="sourceLine" id="cb2-4" title="4">   MB</a>
<a class="sourceLine" id="cb2-5" title="5">   GB</a>
<a class="sourceLine" id="cb2-6" title="6">   TB</a>
<a class="sourceLine" id="cb2-7" title="7">   PB</a>
<a class="sourceLine" id="cb2-8" title="8">   EB</a>
<a class="sourceLine" id="cb2-9" title="9">   ZB</a>
<a class="sourceLine" id="cb2-10" title="10">   YB</a>
<a class="sourceLine" id="cb2-11" title="11">)</a></code></pre></div>
<ul>
<li>指针
<ul>
<li>不可以进行指针的运算</li>
<li><code>&amp;</code>为取址，<code>*</code>为访问指针对象</li>
<li>默认值是<code>nul</code></li>
</ul></li>
<li><code>++</code>与<code>--</code>不是表达式而为语句，不可以作为表达式赋值给某一变量</li>
</ul>
<h4 id="控制语句">控制语句</h4>
<h5 id="条件语句">条件语句</h5>
<ul>
<li><p>条件表达式没有括号</p></li>
<li><p>支持初始化表达式</p>
<ul>
<li><div class="sourceCode" id="cb3"><pre class="sourceCode go"><code class="sourceCode go"><a class="sourceLine" id="cb3-1" title="1"><span class="kw">package</span> main</a>
<a class="sourceLine" id="cb3-2" title="2"></a>
<a class="sourceLine" id="cb3-3" title="3"><span class="kw">import</span> <span class="st">&quot;fmt&quot;</span></a>
<a class="sourceLine" id="cb3-4" title="4"></a>
<a class="sourceLine" id="cb3-5" title="5"><span class="kw">func</span> main()  {</a>
<a class="sourceLine" id="cb3-6" title="6">   <span class="kw">if</span> a := <span class="dv">1</span>;a&gt;<span class="dv">0</span>{</a>
<a class="sourceLine" id="cb3-7" title="7">      fmt.Print(<span class="st">&quot;ok&quot;</span>)</a>
<a class="sourceLine" id="cb3-8" title="8">   }</a>
<a class="sourceLine" id="cb3-9" title="9">}</a></code></pre></div></li>
<li><p><code>if</code>或<code>else</code>连接的左大括号必须与<code>if</code>或<code>else</code>在同一行</p>
<h5 id="循环语句">循环语句</h5>
<ul>
<li><p>只存在<code>for</code>为关键字的循环语句</p></li>
<li><p>存在三种形式</p>
<ul>
<li><div class="sourceCode" id="cb4"><pre class="sourceCode go"><code class="sourceCode go"><a class="sourceLine" id="cb4-1" title="1"><span class="kw">package</span> main</a>
<a class="sourceLine" id="cb4-2" title="2"></a>
<a class="sourceLine" id="cb4-3" title="3"><span class="kw">import</span> <span class="st">&quot;fmt&quot;</span></a>
<a class="sourceLine" id="cb4-4" title="4"></a>
<a class="sourceLine" id="cb4-5" title="5"><span class="kw">func</span> main()  {</a>
<a class="sourceLine" id="cb4-6" title="6">   a := <span class="dv">1</span></a>
<a class="sourceLine" id="cb4-7" title="7">   <span class="kw">for</span> {</a>
<a class="sourceLine" id="cb4-8" title="8">      a ++</a>
<a class="sourceLine" id="cb4-9" title="9">      <span class="kw">if</span> a&gt;<span class="dv">5</span>{</a>
<a class="sourceLine" id="cb4-10" title="10">         <span class="kw">break</span></a>
<a class="sourceLine" id="cb4-11" title="11">      }</a>
<a class="sourceLine" id="cb4-12" title="12">   }</a>
<a class="sourceLine" id="cb4-13" title="13">   fmt.Print(a)</a>
<a class="sourceLine" id="cb4-14" title="14">}</a></code></pre></div></li>
<li>```go package main</li>
</ul>
<p>import “fmt”</p>
<p>func main() { a := 1 for a &lt; 5 { a ++ } fmt.Print(a) } ```</p>
<ul>
<li><div class="sourceCode" id="cb5"><pre class="sourceCode go"><code class="sourceCode go"><a class="sourceLine" id="cb5-1" title="1"><span class="kw">package</span> main</a>
<a class="sourceLine" id="cb5-2" title="2"></a>
<a class="sourceLine" id="cb5-3" title="3"><span class="kw">import</span> <span class="st">&quot;fmt&quot;</span></a>
<a class="sourceLine" id="cb5-4" title="4"></a>
<a class="sourceLine" id="cb5-5" title="5"><span class="kw">func</span> main()  {</a>
<a class="sourceLine" id="cb5-6" title="6">   a := <span class="dv">1</span></a>
<a class="sourceLine" id="cb5-7" title="7">   <span class="kw">for</span> i := <span class="dv">0</span>;i&lt;<span class="dv">10</span>;i++ {</a>
<a class="sourceLine" id="cb5-8" title="8">      a ++</a>
<a class="sourceLine" id="cb5-9" title="9">   }</a>
<a class="sourceLine" id="cb5-10" title="10">   fmt.Print(a)</a>
<a class="sourceLine" id="cb5-11" title="11">}</a></code></pre></div></li>
</ul></li>
<li><p>左大括号需要与for在同一行</p></li>
<li><p>不建议在条件语句中使用函数，如果是函数则会在每次循环时都执行一遍函数，拖慢速度</p></li>
</ul></li>
</ul></li>
</ul>
<h5 id="选择语句switch">选择语句(switch)</h5>
<ul>
<li><p>不需要写break，一旦找到符合的，直接跳出整个switch语句块。如果不希望跳出，使用<code>fallthrough</code>语句</p></li>
<li><p>若条件为表达式，需要加分号</p></li>
<li><p>代码示例</p>
<ul>
<li><div class="sourceCode" id="cb6"><pre class="sourceCode go"><code class="sourceCode go"><a class="sourceLine" id="cb6-1" title="1"><span class="kw">func</span> main()  {</a>
<a class="sourceLine" id="cb6-2" title="2">    a := <span class="dv">1</span></a>
<a class="sourceLine" id="cb6-3" title="3">    <span class="kw">switch</span> a {</a>
<a class="sourceLine" id="cb6-4" title="4">    <span class="kw">case</span> <span class="dv">0</span>:</a>
<a class="sourceLine" id="cb6-5" title="5">        fmt.Print(<span class="st">&quot;0&quot;</span>)</a>
<a class="sourceLine" id="cb6-6" title="6">    <span class="kw">case</span> <span class="dv">1</span>:</a>
<a class="sourceLine" id="cb6-7" title="7">        fmt.Print(<span class="st">&quot;1&quot;</span>)</a>
<a class="sourceLine" id="cb6-8" title="8">    <span class="kw">case</span> <span class="dv">2</span>:</a>
<a class="sourceLine" id="cb6-9" title="9">        fmt.Print(<span class="st">&quot;2&quot;</span>)</a>
<a class="sourceLine" id="cb6-10" title="10">    <span class="kw">default</span>:</a>
<a class="sourceLine" id="cb6-11" title="11">        fmt.Print(<span class="st">&quot;can&#39;t find&quot;</span>)</a>
<a class="sourceLine" id="cb6-12" title="12">    }</a>
<a class="sourceLine" id="cb6-13" title="13">}</a></code></pre></div></li>
<li><div class="sourceCode" id="cb7"><pre class="sourceCode go"><code class="sourceCode go"><a class="sourceLine" id="cb7-1" title="1"><span class="kw">func</span> main()  {</a>
<a class="sourceLine" id="cb7-2" title="2">    a := <span class="dv">1</span></a>
<a class="sourceLine" id="cb7-3" title="3">    <span class="kw">switch</span>  {</a>
<a class="sourceLine" id="cb7-4" title="4">    <span class="kw">case</span> a == <span class="dv">0</span>:</a>
<a class="sourceLine" id="cb7-5" title="5">        fmt.Print(<span class="st">&quot;0&quot;</span>)</a>
<a class="sourceLine" id="cb7-6" title="6">    <span class="kw">case</span> a == <span class="dv">1</span>:</a>
<a class="sourceLine" id="cb7-7" title="7">        fmt.Print(<span class="st">&quot;1&quot;</span>)</a>
<a class="sourceLine" id="cb7-8" title="8">    <span class="kw">case</span> a == <span class="dv">2</span>:</a>
<a class="sourceLine" id="cb7-9" title="9">        fmt.Print(<span class="st">&quot;2&quot;</span>)</a>
<a class="sourceLine" id="cb7-10" title="10">    <span class="kw">default</span>:</a>
<a class="sourceLine" id="cb7-11" title="11">        fmt.Print(<span class="st">&quot;can&#39;t find&quot;</span>)</a>
<a class="sourceLine" id="cb7-12" title="12">    }</a>
<a class="sourceLine" id="cb7-13" title="13">}</a></code></pre></div></li>
<li><div class="sourceCode" id="cb8"><pre class="sourceCode go"><code class="sourceCode go"><a class="sourceLine" id="cb8-1" title="1"><span class="kw">func</span> main()  {</a>
<a class="sourceLine" id="cb8-2" title="2">    <span class="kw">switch</span>  a := <span class="dv">1</span>;{</a>
<a class="sourceLine" id="cb8-3" title="3">    <span class="kw">case</span> a == <span class="dv">0</span>:</a>
<a class="sourceLine" id="cb8-4" title="4">        fmt.Print(<span class="st">&quot;0&quot;</span>)</a>
<a class="sourceLine" id="cb8-5" title="5">    <span class="kw">case</span> a == <span class="dv">1</span>:</a>
<a class="sourceLine" id="cb8-6" title="6">        fmt.Print(<span class="st">&quot;1&quot;</span>)</a>
<a class="sourceLine" id="cb8-7" title="7">    <span class="kw">case</span> a == <span class="dv">2</span>:</a>
<a class="sourceLine" id="cb8-8" title="8">        fmt.Print(<span class="st">&quot;2&quot;</span>)</a>
<a class="sourceLine" id="cb8-9" title="9">    <span class="kw">default</span>:</a>
<a class="sourceLine" id="cb8-10" title="10">        fmt.Print(<span class="st">&quot;can&#39;t find&quot;</span>)</a>
<a class="sourceLine" id="cb8-11" title="11">    }</a>
<a class="sourceLine" id="cb8-12" title="12">}</a></code></pre></div></li>
</ul></li>
</ul>
<h5 id="跳转语句">跳转语句</h5>
<ul>
<li><p><code>break</code>、<code>continue</code>、<code>goto</code>可以配合使用</p></li>
<li><p>标签名区分大小写</p></li>
<li><div class="sourceCode" id="cb9"><pre class="sourceCode go"><code class="sourceCode go"><a class="sourceLine" id="cb9-1" title="1"><span class="kw">func</span> main()  {</a>
<a class="sourceLine" id="cb9-2" title="2">    LABLE1:</a>
<a class="sourceLine" id="cb9-3" title="3">    <span class="kw">for</span> {</a>
<a class="sourceLine" id="cb9-4" title="4">        <span class="kw">for</span> i:= <span class="dv">0</span>; i &lt; <span class="dv">10</span>; i++{</a>
<a class="sourceLine" id="cb9-5" title="5">            <span class="kw">if</span> i &gt; <span class="dv">3</span> {</a>
<a class="sourceLine" id="cb9-6" title="6">                <span class="kw">break</span> LABLE1</a>
<a class="sourceLine" id="cb9-7" title="7">            }</a>
<a class="sourceLine" id="cb9-8" title="8">        }</a>
<a class="sourceLine" id="cb9-9" title="9">    }</a>
<a class="sourceLine" id="cb9-10" title="10">}</a></code></pre></div></li>
<li><p>对于<code>break</code>、<code>continue</code>会跳转到这个循环结束</p></li>
<li><p>对于<code>goto</code>会跳转到代码行所在位置</p></li>
</ul>
<h4 id="数组">数组</h4>
<ul>
<li><p>定义：var <变量名> [数组长度，也可以为空或<code>…]&lt;每一个元素的类型&gt; {初始化的值，用逗号隔开，或使用</code>索引:值`}</p></li>
<li><p>长度为类型的一部分</p></li>
<li><p>数据是值类型</p></li>
<li><p>可以使用 <code>==</code> 以及 <code>!=</code> 但不可以进行大于或等于</p>
<ul>
<li>类型要相同才可以比较(长度数据类型的一部分)</li>
</ul></li>
<li><p>数据的截取与Python语法相同</p></li>
<li><p><code>new</code>可以建立新的指向数组的指针</p>
<ul>
<li><div class="sourceCode" id="cb10"><pre class="sourceCode go"><code class="sourceCode go"><a class="sourceLine" id="cb10-1" title="1"><span class="kw">func</span> main()  {</a>
<a class="sourceLine" id="cb10-2" title="2">  a := [<span class="dv">10</span>]<span class="dt">int</span>{}</a>
<a class="sourceLine" id="cb10-3" title="3">  a[<span class="dv">1</span>] = <span class="dv">2</span></a>
<a class="sourceLine" id="cb10-4" title="4">  fmt.Print(a)</a>
<a class="sourceLine" id="cb10-5" title="5">  p := <span class="bu">new</span>([<span class="dv">10</span>]<span class="dt">int</span>)</a>
<a class="sourceLine" id="cb10-6" title="6">  p[<span class="dv">1</span>] = <span class="dv">2</span></a>
<a class="sourceLine" id="cb10-7" title="7">  fmt.Print(p)</a>
<a class="sourceLine" id="cb10-8" title="8">}</a></code></pre></div></li>
</ul></li>
<li><p>多维数据</p>
<ul>
<li><div class="sourceCode" id="cb11"><pre class="sourceCode go"><code class="sourceCode go"><a class="sourceLine" id="cb11-1" title="1"><span class="kw">func</span> main()  {</a>
<a class="sourceLine" id="cb11-2" title="2">    a := [][]<span class="dt">int</span>{</a>
<a class="sourceLine" id="cb11-3" title="3">        {<span class="dv">1</span>:<span class="dv">1</span>},</a>
<a class="sourceLine" id="cb11-4" title="4">        {<span class="dv">2</span>:<span class="dv">1</span>},</a>
<a class="sourceLine" id="cb11-5" title="5">    }</a>
<a class="sourceLine" id="cb11-6" title="6">    fmt.Print(a)</a>
<a class="sourceLine" id="cb11-7" title="7">}</a></code></pre></div></li>
</ul></li>
<li><p>冒泡排序</p>
<ul>
<li><div class="sourceCode" id="cb12"><pre class="sourceCode go"><code class="sourceCode go"><a class="sourceLine" id="cb12-1" title="1"><span class="kw">func</span> main()  {</a>
<a class="sourceLine" id="cb12-2" title="2">    a := []<span class="dt">int</span>{<span class="dv">5</span>,<span class="dv">4</span>,<span class="dv">8</span>,<span class="dv">7</span>,<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">6</span>,<span class="dv">4</span>,<span class="dv">2</span>,<span class="dv">5</span>,<span class="dv">8</span>,<span class="dv">9</span>,<span class="dv">7</span>,<span class="dv">1</span>,<span class="dv">3</span>}</a>
<a class="sourceLine" id="cb12-3" title="3">    a_len := <span class="bu">len</span>(a)</a>
<a class="sourceLine" id="cb12-4" title="4">    <span class="kw">for</span> i := <span class="dv">0</span>;i &lt; a_len<span class="dv">-1</span>; i++{</a>
<a class="sourceLine" id="cb12-5" title="5">        <span class="kw">for</span> j := <span class="dv">0</span>; j &lt; a_len<span class="dv">-1</span>; j++{</a>
<a class="sourceLine" id="cb12-6" title="6">            <span class="kw">if</span> a[j] &gt; a[j+<span class="dv">1</span>]{</a>
<a class="sourceLine" id="cb12-7" title="7">                temp := a[j]</a>
<a class="sourceLine" id="cb12-8" title="8">                a[j] = a[j+<span class="dv">1</span>]</a>
<a class="sourceLine" id="cb12-9" title="9">                a[j+<span class="dv">1</span>] = temp</a>
<a class="sourceLine" id="cb12-10" title="10">            }</a>
<a class="sourceLine" id="cb12-11" title="11">        }</a>
<a class="sourceLine" id="cb12-12" title="12">    }</a>
<a class="sourceLine" id="cb12-13" title="13">    fmt.Print(a)</a>
<a class="sourceLine" id="cb12-14" title="14">}</a></code></pre></div></li>
</ul></li>
</ul>
<h4 id="切片slice">切片slice</h4>
<ul>
<li><p>本身不是数组但是指向底层的数组</p></li>
<li><p>作为边长数组的替代方案，可以关联底层数据的局部或全部</p></li>
<li><p>应用类型</p></li>
<li><p>可以直接创建或从底层数据获取生成</p></li>
<li><p><code>len()</code>获取元素个数，<code>cap()</code>获取容量</p></li>
<li><p>可使用mark创建</p></li>
<li><p>多个slice指向同一个数组时，其中一个值改变会影响全部</p></li>
<li><p>声明</p>
<ul>
<li>make([]T,len,cap)</li>
<li>其中cap可以省略，默认值与len相同</li>
</ul></li>
<li><p>通过截取数组获得</p>
<ul>
<li><div class="sourceCode" id="cb13"><pre class="sourceCode go"><code class="sourceCode go"><a class="sourceLine" id="cb13-1" title="1"><span class="kw">func</span> main()  {</a>
<a class="sourceLine" id="cb13-2" title="2">    a := [<span class="dv">11</span>]<span class="dt">int</span>{}</a>
<a class="sourceLine" id="cb13-3" title="3">    fmt.Println(a)</a>
<a class="sourceLine" id="cb13-4" title="4">    b := a[:]</a>
<a class="sourceLine" id="cb13-5" title="5">    fmt.Println(b)</a>
<a class="sourceLine" id="cb13-6" title="6">}</a></code></pre></div></li>
</ul></li>
<li><p>Reslice</p>
<ul>
<li>以基准的slice切片为基准</li>
<li>不可以超过slice切片的容量</li>
<li>索引越界不会导致底层数组重新分配而是引发错误</li>
</ul></li>
<li><p>相关操作</p>
<ul>
<li><p>append</p>
<ul>
<li><p>可以在slice尾部追加元素</p></li>
<li><p>可以将一个slice追加到另一个slice的尾部</p></li>
<li><p>如果长度未超过追加后的容量则发挥原始的slice</p></li>
<li><p>否则重新分类内存地址并返回新的slice</p></li>
<li><p>用法：</p>
<ul>
<li><pre><code>  s1 = append(s1, 1, 2, 3, 4, 5) </code></pre></li>
<li><div class="sourceCode" id="cb15"><pre class="sourceCode go"><code class="sourceCode go"><a class="sourceLine" id="cb15-1" title="1">  a := []<span class="dt">int</span>{<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">5</span>}</a>
<a class="sourceLine" id="cb15-2" title="2">  b := []<span class="dt">int</span>{<span class="dv">6</span>,<span class="dv">7</span>,<span class="dv">8</span>,<span class="dv">9</span>,<span class="dv">0</span>}</a>
<a class="sourceLine" id="cb15-3" title="3">      a = <span class="bu">append</span>(a, b...)</a>
<a class="sourceLine" id="cb15-4" title="4">      fmt.Println(a)</a></code></pre></div></li>
</ul></li>
</ul></li>
<li><p>copy</p>
<ul>
<li><div class="sourceCode" id="cb16"><pre class="sourceCode go"><code class="sourceCode go"><a class="sourceLine" id="cb16-1" title="1"><span class="bu">copy</span>(s1, s2)<span class="co">//将s2拷贝到s1</span></a></code></pre></div></li>
<li>长度以<code>s1</code>为基准，内容以<code>s2</code>为基准</li>
</ul></li>
<li><p>迭代循环</p>
<ul>
<li><div class="sourceCode" id="cb17"><pre class="sourceCode go"><code class="sourceCode go"><a class="sourceLine" id="cb17-1" title="1">  <span class="kw">func</span> main()  {</a>
<a class="sourceLine" id="cb17-2" title="2">  a := [<span class="dv">11</span>]<span class="dt">int</span>{}</a>
<a class="sourceLine" id="cb17-3" title="3">      fmt.Println(a)</a>
<a class="sourceLine" id="cb17-4" title="4">      b := a[:]</a>
<a class="sourceLine" id="cb17-5" title="5">      <span class="kw">for</span> i,v := <span class="kw">range</span> b{  <span class="co">// i为索引，v为该索引位置的值(拷贝)，直接对v修改不会改变slice的值</span></a>
<a class="sourceLine" id="cb17-6" title="6">          fmt.Println(i,v)</a>
<a class="sourceLine" id="cb17-7" title="7">      }</a>
<a class="sourceLine" id="cb17-8" title="8">  }</a></code></pre></div></li>
<li></li>
</ul></li>
</ul></li>
</ul>
<h4 id="map">map</h4>
<ul>
<li><p>类似于哈希表或者字典，以key-value形式存储数据</p></li>
<li><p>key不可以是函数、map或slice</p></li>
<li><p>map查找比线性搜索快，但比索引访问数据慢100倍</p></li>
<li><p>使用<code>make()</code>创建，支持<code>:=</code>的简写形式</p></li>
<li><p>声明</p>
<ul>
<li>make([key的类型]value的类型, 容量)，cap代表容量，可以省略</li>
<li>超出容量时会自动扩容</li>
<li><code>len()</code>代表长度，<code>cap()</code>代表容量</li>
</ul></li>
<li><p>键值对不存在时自动添加，使用<code>delete(map，key)</code>删除某一键值对</p></li>
<li><p>使用for range对map和slice进行迭代操作</p></li>
<li><p>读写操作与Python相同</p></li>
<li><p>map中嵌套map的例子</p>
<ul>
<li><div class="sourceCode" id="cb18"><pre class="sourceCode go"><code class="sourceCode go"><a class="sourceLine" id="cb18-1" title="1"><span class="kw">func</span> main()  {</a>
<a class="sourceLine" id="cb18-2" title="2">    m := <span class="bu">make</span>(<span class="kw">map</span>[<span class="dt">int</span>]<span class="kw">map</span>[<span class="dt">int</span>]<span class="dt">string</span>)</a>
<a class="sourceLine" id="cb18-3" title="3">    m[<span class="dv">1</span>] = <span class="bu">make</span>(<span class="kw">map</span>[<span class="dt">int</span>]<span class="dt">string</span>)</a>
<a class="sourceLine" id="cb18-4" title="4">    m[<span class="dv">1</span>][<span class="dv">1</span>] = <span class="st">&quot;10&quot;</span></a>
<a class="sourceLine" id="cb18-5" title="5">    fmt.Print(m)</a>
<a class="sourceLine" id="cb18-6" title="6">}</a></code></pre></div></li>
<li><p>需要对每一级的map进行单独的初始化</p></li>
<li><p>需要判断每一级的map是否已经被初始化了</p></li>
</ul></li>
<li><p>利用状态判断键值对是否被初始化了</p>
<ul>
<li><div class="sourceCode" id="cb19"><pre class="sourceCode go"><code class="sourceCode go"><a class="sourceLine" id="cb19-1" title="1"><span class="kw">func</span> main()  {</a>
<a class="sourceLine" id="cb19-2" title="2">    m := <span class="bu">make</span>(<span class="kw">map</span>[<span class="dt">int</span>]<span class="kw">map</span>[<span class="dt">int</span>]<span class="dt">string</span>)</a>
<a class="sourceLine" id="cb19-3" title="3">    m[<span class="dv">1</span>] = <span class="bu">make</span>(<span class="kw">map</span>[<span class="dt">int</span>]<span class="dt">string</span>)</a>
<a class="sourceLine" id="cb19-4" title="4">    a, status := m[<span class="dv">1</span>]  <span class="co">//第二个返回值代表了键值对是否存在</span></a>
<a class="sourceLine" id="cb19-5" title="5">    fmt.Println(a,status)</a>
<a class="sourceLine" id="cb19-6" title="6">}</a></code></pre></div></li>
</ul></li>
<li><p>迭代取值</p>
<ul>
<li><div class="sourceCode" id="cb20"><pre class="sourceCode go"><code class="sourceCode go"><a class="sourceLine" id="cb20-1" title="1">  <span class="kw">func</span> main()  {</a>
<a class="sourceLine" id="cb20-2" title="2">      a := <span class="bu">make</span>(<span class="kw">map</span>[<span class="dt">int</span>]<span class="dt">int</span>)</a>
<a class="sourceLine" id="cb20-3" title="3">      a[<span class="dv">1</span>] = <span class="dv">1</span></a>
<a class="sourceLine" id="cb20-4" title="4">      a[<span class="dv">2</span>]=<span class="dv">2</span></a>
<a class="sourceLine" id="cb20-5" title="5">      <span class="kw">for</span> k,v := <span class="kw">range</span> a{  <span class="co">// k,v为map中对应的键值对</span></a>
<a class="sourceLine" id="cb20-6" title="6">          fmt.Println(k,v)</a>
<a class="sourceLine" id="cb20-7" title="7">      }</a>
<a class="sourceLine" id="cb20-8" title="8">  }</a></code></pre></div></li>
<li><p>验证在slice中获得的值为拷贝的例子</p>
<ul>
<li><div class="sourceCode" id="cb21"><pre class="sourceCode go"><code class="sourceCode go"><a class="sourceLine" id="cb21-1" title="1">  <span class="kw">func</span> main()  {</a>
<a class="sourceLine" id="cb21-2" title="2">      s := <span class="bu">make</span>([]<span class="kw">map</span>[<span class="dt">int</span>]<span class="dt">int</span>, <span class="dv">10</span>)</a>
<a class="sourceLine" id="cb21-3" title="3">      <span class="kw">for</span> _, v := <span class="kw">range</span> s{</a>
<a class="sourceLine" id="cb21-4" title="4">          v = <span class="bu">make</span>(<span class="kw">map</span>[<span class="dt">int</span>]<span class="dt">int</span>)</a>
<a class="sourceLine" id="cb21-5" title="5">          v[<span class="dv">1</span>] = <span class="dv">1</span></a>
<a class="sourceLine" id="cb21-6" title="6">      }</a>
<a class="sourceLine" id="cb21-7" title="7">      fmt.Println(s)</a>
<a class="sourceLine" id="cb21-8" title="8"></a>
<a class="sourceLine" id="cb21-9" title="9">      <span class="kw">for</span> i, _ := <span class="kw">range</span> s{</a>
<a class="sourceLine" id="cb21-10" title="10">          s[i] = <span class="bu">make</span>(<span class="kw">map</span>[<span class="dt">int</span>]<span class="dt">int</span>)</a>
<a class="sourceLine" id="cb21-11" title="11">          s[i][<span class="dv">1</span>] = <span class="dv">1</span></a>
<a class="sourceLine" id="cb21-12" title="12">      }</a>
<a class="sourceLine" id="cb21-13" title="13">      fmt.Println(s)</a>
<a class="sourceLine" id="cb21-14" title="14">  }</a></code></pre></div></li>
</ul></li>
</ul></li>
</ul>
<h4 id="函数function">函数function</h4>
<ul>
<li><p>不支持嵌套、重载和默认参数</p></li>
<li><p>支持特性</p>
<ul>
<li>无需声明原型</li>
<li>不定长度变参</li>
<li>多返回值</li>
<li>命名返回值参数</li>
<li>匿名函数(不可以作为外层函数)</li>
<li>闭包</li>
</ul></li>
<li><p><code>func</code>，左大括号要在同一行</p></li>
<li><p>函数可以作为类型使用</p></li>
<li><p>一些实例</p>
<ul>
<li><div class="sourceCode" id="cb22"><pre class="sourceCode go"><code class="sourceCode go"><a class="sourceLine" id="cb22-1" title="1"><span class="kw">func</span> test(a,b,c <span class="dt">int</span>)  (d,e,f <span class="dt">int</span>){}</a></code></pre></div></li>
<li><div class="sourceCode" id="cb23"><pre class="sourceCode go"><code class="sourceCode go"><a class="sourceLine" id="cb23-1" title="1"><span class="kw">func</span> test() (<span class="dt">int</span>, <span class="dt">int</span>, <span class="dt">int</span>){}</a></code></pre></div></li>
<li><div class="sourceCode" id="cb24"><pre class="sourceCode go"><code class="sourceCode go"><a class="sourceLine" id="cb24-1" title="1"><span class="kw">func</span> test(a ...<span class="dt">int</span>)  {</a>
<a class="sourceLine" id="cb24-2" title="2">    <span class="co">/*</span></a>
<a class="sourceLine" id="cb24-3" title="3"><span class="co">    不定长参数的传递：</span></a>
<a class="sourceLine" id="cb24-4" title="4"><span class="co">        - 不定参参数只能卸载参数列表是最后一个</span></a>
<a class="sourceLine" id="cb24-5" title="5"><span class="co">        - 传入的a为slice类型</span></a>
<a class="sourceLine" id="cb24-6" title="6"><span class="co">        - 传入是只是拷贝，修改值并不会以影响原始的变量的值</span></a>
<a class="sourceLine" id="cb24-7" title="7"><span class="co">    */</span></a>
<a class="sourceLine" id="cb24-8" title="8">    fmt.Println(a)</a>
<a class="sourceLine" id="cb24-9" title="9">}</a></code></pre></div></li>
<li><div class="sourceCode" id="cb25"><pre class="sourceCode go"><code class="sourceCode go"><a class="sourceLine" id="cb25-1" title="1"><span class="kw">func</span> test(s []<span class="dt">int</span>)  {</a>
<a class="sourceLine" id="cb25-2" title="2">    <span class="co">/*</span></a>
<a class="sourceLine" id="cb25-3" title="3"><span class="co">    传入的参数为slice形式的时候</span></a>
<a class="sourceLine" id="cb25-4" title="4"><span class="co">        - 对其值改变会导致原始值的改变</span></a>
<a class="sourceLine" id="cb25-5" title="5"><span class="co">        - 传入的仍是拷贝，但由于slice是引用类型，所以拷贝进来的还是内存地址</span></a>
<a class="sourceLine" id="cb25-6" title="6"><span class="co">    */</span></a>
<a class="sourceLine" id="cb25-7" title="7">}</a></code></pre></div></li>
<li><div class="sourceCode" id="cb26"><pre class="sourceCode go"><code class="sourceCode go"><a class="sourceLine" id="cb26-1" title="1"><span class="co">/*</span></a>
<a class="sourceLine" id="cb26-2" title="2"><span class="co">利用指针在函数中对原始值进行操作</span></a>
<a class="sourceLine" id="cb26-3" title="3"><span class="co">*/</span></a>
<a class="sourceLine" id="cb26-4" title="4"><span class="kw">func</span> main()  {</a>
<a class="sourceLine" id="cb26-5" title="5">    s1 := <span class="dv">1</span></a>
<a class="sourceLine" id="cb26-6" title="6">    test(&amp;s1)</a>
<a class="sourceLine" id="cb26-7" title="7">    fmt.Println(s1)</a>
<a class="sourceLine" id="cb26-8" title="8">}</a>
<a class="sourceLine" id="cb26-9" title="9"></a>
<a class="sourceLine" id="cb26-10" title="10"><span class="kw">func</span> test(s *<span class="dt">int</span>)  {</a>
<a class="sourceLine" id="cb26-11" title="11">    *s++</a>
<a class="sourceLine" id="cb26-12" title="12">    fmt.Println(*s)</a>
<a class="sourceLine" id="cb26-13" title="13">}</a></code></pre></div></li>
<li><div class="sourceCode" id="cb27"><pre class="sourceCode go"><code class="sourceCode go"><a class="sourceLine" id="cb27-1" title="1"><span class="kw">func</span> main()  {</a>
<a class="sourceLine" id="cb27-2" title="2">    a := <span class="kw">func</span>() {fmt.Println(<span class="st">&quot;匿名函数&quot;</span>)}</a>
<a class="sourceLine" id="cb27-3" title="3">    a()</a>
<a class="sourceLine" id="cb27-4" title="4">}</a></code></pre></div></li>
<li><pre><code>
//闭包
func main()  {
    f := closure(10)  // 此时f为一个函数，传入值为y，返回值为10+y
    fmt.Println(f(1))
}

func closure(x int)  func(int) int{
    return func(y int) int {
        return x + y
    }
}</code></pre></li>
</ul></li>
<li><p>defer</p>
<ul>
<li><p>执行方式类似于析构函数，在函数体执行结束后按照调用的相反顺序逐个执行</p></li>
<li><p>即使函数发生<strong>严重错误</strong>也会执行</p></li>
<li><p>支持匿名函数的调用</p></li>
<li><p>常用语资源清理，文件关闭、解锁以及记录时间等操作</p></li>
<li><p>通过与匿名函数的配合在return后修改函数计算结果</p></li>
<li><p>如果函数体内某个变量作为defer时匿名函数的参数，则在定义defer时已经获得了拷贝，否则则是引用某个变量地址</p></li>
<li><p>代码样例</p>
<ul>
<li><div class="sourceCode" id="cb29"><pre class="sourceCode go"><code class="sourceCode go"><a class="sourceLine" id="cb29-1" title="1">  <span class="kw">func</span> main()  {</a>
<a class="sourceLine" id="cb29-2" title="2">      <span class="co">/*</span></a>
<a class="sourceLine" id="cb29-3" title="3"><span class="co">      - 输出结果为132</span></a>
<a class="sourceLine" id="cb29-4" title="4"><span class="co">      - defer在程序执行结束后执行</span></a>
<a class="sourceLine" id="cb29-5" title="5"><span class="co">      - defer逆序往上调用</span></a>
<a class="sourceLine" id="cb29-6" title="6"><span class="co">       */</span></a>
<a class="sourceLine" id="cb29-7" title="7">      fmt.Printf(<span class="st">&quot;1&quot;</span>)</a>
<a class="sourceLine" id="cb29-8" title="8">      <span class="kw">defer</span> fmt.Printf(<span class="st">&quot;2&quot;</span>)</a>
<a class="sourceLine" id="cb29-9" title="9">      <span class="kw">defer</span> fmt.Printf(<span class="st">&quot;3&quot;</span>)</a>
<a class="sourceLine" id="cb29-10" title="10">  }</a></code></pre></div></li>
<li></li>
</ul></li>
</ul></li>
<li><p>没有异常机制，可以通过panic/recover来处理错误</p></li>
<li><p>panic可以在任何地方引发，但recover只有在defer调用的函数中有效</p></li>
<li><div class="sourceCode" id="cb30"><pre class="sourceCode go"><code class="sourceCode go"><a class="sourceLine" id="cb30-1" title="1"><span class="kw">func</span> main()  {</a>
<a class="sourceLine" id="cb30-2" title="2">  a()</a>
<a class="sourceLine" id="cb30-3" title="3">  b()</a>
<a class="sourceLine" id="cb30-4" title="4">  c()</a>
<a class="sourceLine" id="cb30-5" title="5">}</a>
<a class="sourceLine" id="cb30-6" title="6"></a>
<a class="sourceLine" id="cb30-7" title="7"><span class="kw">func</span> a(){</a>
<a class="sourceLine" id="cb30-8" title="8">  fmt.Println(<span class="st">&quot;a&quot;</span>)</a>
<a class="sourceLine" id="cb30-9" title="9">}</a>
<a class="sourceLine" id="cb30-10" title="10"></a>
<a class="sourceLine" id="cb30-11" title="11"><span class="kw">func</span> b()  {</a>
<a class="sourceLine" id="cb30-12" title="12">  <span class="kw">defer</span> <span class="kw">func</span>() {  <span class="co">//defer需要放在panic之前</span></a>
<a class="sourceLine" id="cb30-13" title="13">      <span class="kw">if</span> err := <span class="bu">recover</span>(); err != <span class="ot">nil</span>{</a>
<a class="sourceLine" id="cb30-14" title="14">          fmt.Println(<span class="st">&quot;Recover b&quot;</span>)</a>
<a class="sourceLine" id="cb30-15" title="15">      }</a>
<a class="sourceLine" id="cb30-16" title="16">  }()</a>
<a class="sourceLine" id="cb30-17" title="17"></a>
<a class="sourceLine" id="cb30-18" title="18">  <span class="bu">panic</span>(<span class="st">&quot;b&quot;</span>)  <span class="co">//此处会引发异常</span></a>
<a class="sourceLine" id="cb30-19" title="19">}</a>
<a class="sourceLine" id="cb30-20" title="20"></a>
<a class="sourceLine" id="cb30-21" title="21"><span class="kw">func</span> c()  {</a>
<a class="sourceLine" id="cb30-22" title="22">  fmt.Println(<span class="st">&quot;c&quot;</span>)</a>
<a class="sourceLine" id="cb30-23" title="23">}</a></code></pre></div></li>
</ul>
<h4 id="结构-struct">结构 struct</h4>
<ul>
<li><p>go没有class</p></li>
<li><p>使用type<name> struct{}定义结构</p></li>
<li><p>支持指向自身的指针类型成员</p></li>
<li><p>支持匿名结构，可做成员或定于成员变量</p></li>
<li><p>匿名结构也可以作为map的值</p></li>
<li><p>可以使用字面值对结构初始化</p></li>
<li><p>允许通过指针来读写结构成员</p></li>
<li><p>相同类型的成员可以进行直接拷贝赋值</p></li>
<li><p>支持 <code>==</code>与<code>!=</code>比较运算符当不支持大于或小于</p></li>
<li><p>支持匿名字段，本质上是定义了以某个类型名为名称的字段</p></li>
<li><p>可以使用匿名字段指针</p></li>
<li><p>建议在初始化的时候使用<code>&amp;</code>直接获取地址</p></li>
<li><p>是值类型</p></li>
<li><p>一些代码示例</p>
<ul>
<li><div class="sourceCode" id="cb31"><pre class="sourceCode go"><code class="sourceCode go"><a class="sourceLine" id="cb31-1" title="1"><span class="kw">type</span> persion <span class="kw">struct</span> {</a>
<a class="sourceLine" id="cb31-2" title="2">    name <span class="dt">string</span></a>
<a class="sourceLine" id="cb31-3" title="3">    age  <span class="dt">int</span></a>
<a class="sourceLine" id="cb31-4" title="4">}</a>
<a class="sourceLine" id="cb31-5" title="5"></a>
<a class="sourceLine" id="cb31-6" title="6"><span class="kw">func</span> main()  {</a>
<a class="sourceLine" id="cb31-7" title="7">    a := persion{</a>
<a class="sourceLine" id="cb31-8" title="8">        name:<span class="st">&quot;name&quot;</span>,</a>
<a class="sourceLine" id="cb31-9" title="9">        age: <span class="dv">18</span>,</a>
<a class="sourceLine" id="cb31-10" title="10">    }</a>
<a class="sourceLine" id="cb31-11" title="11">    b := persion{</a>
<a class="sourceLine" id="cb31-12" title="12">        <span class="st">&quot;name&quot;</span>,</a>
<a class="sourceLine" id="cb31-13" title="13">        <span class="dv">18</span>,</a>
<a class="sourceLine" id="cb31-14" title="14">    }</a>
<a class="sourceLine" id="cb31-15" title="15">    fmt.Println(a)</a>
<a class="sourceLine" id="cb31-16" title="16">    fmt.Println(a==b)</a>
<a class="sourceLine" id="cb31-17" title="17">}</a></code></pre></div></li>
<li><div class="sourceCode" id="cb32"><pre class="sourceCode go"><code class="sourceCode go"><a class="sourceLine" id="cb32-1" title="1"><span class="kw">type</span> human <span class="kw">struct</span> {</a>
<a class="sourceLine" id="cb32-2" title="2">    Sex <span class="dt">int</span></a>
<a class="sourceLine" id="cb32-3" title="3">}</a>
<a class="sourceLine" id="cb32-4" title="4"></a>
<a class="sourceLine" id="cb32-5" title="5"><span class="kw">type</span> teacher <span class="kw">struct</span> {</a>
<a class="sourceLine" id="cb32-6" title="6">    human</a>
<a class="sourceLine" id="cb32-7" title="7">    Name <span class="dt">string</span></a>
<a class="sourceLine" id="cb32-8" title="8">    Age  <span class="dt">int</span></a>
<a class="sourceLine" id="cb32-9" title="9">}</a>
<a class="sourceLine" id="cb32-10" title="10"></a>
<a class="sourceLine" id="cb32-11" title="11"><span class="kw">type</span> student <span class="kw">struct</span> {</a>
<a class="sourceLine" id="cb32-12" title="12">    human</a>
<a class="sourceLine" id="cb32-13" title="13">    Name <span class="dt">string</span></a>
<a class="sourceLine" id="cb32-14" title="14">    Age  <span class="dt">int</span></a>
<a class="sourceLine" id="cb32-15" title="15">}</a>
<a class="sourceLine" id="cb32-16" title="16"></a>
<a class="sourceLine" id="cb32-17" title="17"><span class="kw">func</span> main()  {</a>
<a class="sourceLine" id="cb32-18" title="18">    b := human{Sex:<span class="dv">1</span>}</a>
<a class="sourceLine" id="cb32-19" title="19">    a := student{Name:<span class="st">&quot;name&quot;</span>, human: human{Sex:<span class="dv">1</span>}}  <span class="co">//匿名结构默认结构名为变量名</span></a>
<a class="sourceLine" id="cb32-20" title="20">    a.Sex = <span class="dv">19</span> <span class="co">// 嵌入结构可以直接当做本身的属性来修改值   </span></a>
<a class="sourceLine" id="cb32-21" title="21">    fmt.Println(a, b)</a>
<a class="sourceLine" id="cb32-22" title="22">}</a></code></pre></div></li>
</ul></li>
<li><p>嵌入结构的重名可以按照一个变量来操作 #### 方法method</p></li>
<li><p>通过显示说明receiver来实现与某个类型的组合</p></li>
<li><p>只能为同一个包中的类型定义方法</p></li>
<li><p>receiver可以是类型的值或指针</p></li>
<li><p>不存在方法重载</p></li>
<li><p>可以使用值或指针来调用方法</p></li>
<li><p>从某种意义上来说，方法是函数的语法糖，因为receiver其实就是方法所接收的第一个参数</p></li>
<li><p>如果外部结构和嵌入结构存在同方法名，这邮箱调用外部的结构方法</p></li>
<li><p>类型别名不会拥有底层类型所附带的方法</p></li>
<li><p>方法可以调用结构中的非公开字段</p></li>
<li><p>代码示例</p>
<ul>
<li><div class="sourceCode" id="cb33"><pre class="sourceCode go"><code class="sourceCode go"><a class="sourceLine" id="cb33-1" title="1"><span class="kw">type</span> A <span class="kw">struct</span> {</a>
<a class="sourceLine" id="cb33-2" title="2">    Name <span class="dt">int</span></a>
<a class="sourceLine" id="cb33-3" title="3">}</a>
<a class="sourceLine" id="cb33-4" title="4"></a>
<a class="sourceLine" id="cb33-5" title="5"><span class="kw">func</span> main()  {</a>
<a class="sourceLine" id="cb33-6" title="6">    a := A{}</a>
<a class="sourceLine" id="cb33-7" title="7">    a.Print()</a>
<a class="sourceLine" id="cb33-8" title="8">    fmt.Println(a.Name)</a>
<a class="sourceLine" id="cb33-9" title="9">}</a>
<a class="sourceLine" id="cb33-10" title="10"></a>
<a class="sourceLine" id="cb33-11" title="11"><span class="kw">func</span> (a *A) Print()  {  <span class="co">// 将a与结构A绑定   如果是指针类型的会直接修改a的值</span></a>
<a class="sourceLine" id="cb33-12" title="12">    a.Name = <span class="dv">10</span></a>
<a class="sourceLine" id="cb33-13" title="13">    fmt.Println(*a)</a>
<a class="sourceLine" id="cb33-14" title="14">}</a></code></pre></div></li>
</ul></li>
</ul>
<h4 id="接口interface">接口interface</h4>
<ul>
<li><p>接口是一个或多个方案签名的结合</p></li>
<li><p>只要某个类型拥有改接口的所有方法签名，即算实现该接口，无需显示声明实现了哪个接口，这被称为Structural Typing</p></li>
<li><p>接口只有方法声明，没有实现，没有数据字段</p></li>
<li><p>接口可以匿名嵌入其他接口或嵌入结构中</p></li>
<li><p>将对象赋值给接口时，会发生拷贝，而接口内部存储的是指向这个复制品的指针，既无法修改复制品的状态，也无法获取指针</p></li>
<li><p>只有当接口存储的类型和对象都为nil值，接口才等于nil</p></li>
<li><p>接口调用不会做receiver的自动转换</p></li>
<li><p>接口同样支持匿名字段的方法</p></li>
<li><p>接口也可实现类似OPP中的多态</p></li>
<li><p>空接口可以作为任何类型数据的容器</p></li>
<li><p>一些实例</p>
<ul>
<li><div class="sourceCode" id="cb34"><pre class="sourceCode go"><code class="sourceCode go"><a class="sourceLine" id="cb34-1" title="1">  <span class="co">//接口的实现</span></a>
<a class="sourceLine" id="cb34-2" title="2">  <span class="kw">type</span> USB <span class="kw">interface</span> {</a>
<a class="sourceLine" id="cb34-3" title="3">      Name() <span class="dt">string</span></a>
<a class="sourceLine" id="cb34-4" title="4">      Connect()</a>
<a class="sourceLine" id="cb34-5" title="5">  }</a>
<a class="sourceLine" id="cb34-6" title="6"></a>
<a class="sourceLine" id="cb34-7" title="7">  <span class="kw">type</span> PC <span class="kw">struct</span> {</a>
<a class="sourceLine" id="cb34-8" title="8">      name <span class="dt">string</span></a>
<a class="sourceLine" id="cb34-9" title="9">  }</a>
<a class="sourceLine" id="cb34-10" title="10"></a>
<a class="sourceLine" id="cb34-11" title="11">  <span class="kw">func</span> (pc PC)Name()  <span class="dt">string</span>{</a>
<a class="sourceLine" id="cb34-12" title="12">      <span class="kw">return</span> pc.name</a>
<a class="sourceLine" id="cb34-13" title="13">  }</a>
<a class="sourceLine" id="cb34-14" title="14"></a>
<a class="sourceLine" id="cb34-15" title="15">  <span class="kw">func</span> (pc PC)Connect()  {</a>
<a class="sourceLine" id="cb34-16" title="16">      fmt.Println(pc.name)</a>
<a class="sourceLine" id="cb34-17" title="17">  }</a>
<a class="sourceLine" id="cb34-18" title="18"></a>
<a class="sourceLine" id="cb34-19" title="19">  <span class="kw">func</span> main()  {</a>
<a class="sourceLine" id="cb34-20" title="20">      <span class="kw">var</span> a USB</a>
<a class="sourceLine" id="cb34-21" title="21">      a = PC{<span class="st">&quot;pcpcpcpc&quot;</span>}</a>
<a class="sourceLine" id="cb34-22" title="22">      a.Connect()</a>
<a class="sourceLine" id="cb34-23" title="23">      fmt.Println(a.Name())</a>
<a class="sourceLine" id="cb34-24" title="24">  }</a></code></pre></div></li>
<li><div class="sourceCode" id="cb35"><pre class="sourceCode go"><code class="sourceCode go"><a class="sourceLine" id="cb35-1" title="1">  <span class="kw">type</span> USB <span class="kw">interface</span> {</a>
<a class="sourceLine" id="cb35-2" title="2">      Name() <span class="dt">string</span></a>
<a class="sourceLine" id="cb35-3" title="3">      Connect()</a>
<a class="sourceLine" id="cb35-4" title="4">  }</a>
<a class="sourceLine" id="cb35-5" title="5"></a>
<a class="sourceLine" id="cb35-6" title="6">  <span class="kw">type</span> PC <span class="kw">struct</span> {</a>
<a class="sourceLine" id="cb35-7" title="7">      name <span class="dt">string</span></a>
<a class="sourceLine" id="cb35-8" title="8">  }</a>
<a class="sourceLine" id="cb35-9" title="9"></a>
<a class="sourceLine" id="cb35-10" title="10">  <span class="kw">func</span> (pc PC)Name()  <span class="dt">string</span>{</a>
<a class="sourceLine" id="cb35-11" title="11">      <span class="kw">return</span> pc.name</a>
<a class="sourceLine" id="cb35-12" title="12">  }</a>
<a class="sourceLine" id="cb35-13" title="13"></a>
<a class="sourceLine" id="cb35-14" title="14">  <span class="kw">func</span> (pc PC)Connect()  {</a>
<a class="sourceLine" id="cb35-15" title="15">      fmt.Println(pc.name)</a>
<a class="sourceLine" id="cb35-16" title="16">  }</a>
<a class="sourceLine" id="cb35-17" title="17"></a>
<a class="sourceLine" id="cb35-18" title="18">  <span class="kw">func</span> main()  {</a>
<a class="sourceLine" id="cb35-19" title="19">      <span class="kw">var</span> a USB</a>
<a class="sourceLine" id="cb35-20" title="20">      a = PC{<span class="st">&quot;pcpcpcpc&quot;</span>}</a>
<a class="sourceLine" id="cb35-21" title="21">      a.Connect()</a>
<a class="sourceLine" id="cb35-22" title="22">      fmt.Println(a.Name())</a>
<a class="sourceLine" id="cb35-23" title="23">      disconnect(a)</a>
<a class="sourceLine" id="cb35-24" title="24">  }</a>
<a class="sourceLine" id="cb35-25" title="25"></a>
<a class="sourceLine" id="cb35-26" title="26">  <span class="kw">func</span> disconnect(usb <span class="kw">interface</span>{})  {</a>
<a class="sourceLine" id="cb35-27" title="27">      <span class="kw">if</span> pc, ok := usb.(PC);ok{</a>
<a class="sourceLine" id="cb35-28" title="28">          fmt.Println(pc.name)</a>
<a class="sourceLine" id="cb35-29" title="29">      }</a>
<a class="sourceLine" id="cb35-30" title="30">  }</a></code></pre></div></li>
</ul></li>
<li><p>==type switch== #### 反射reflection</p></li>
<li><p>反射可以提高灵活性，使得<code>interface()</code>有更大的发挥余地</p></li>
<li><p>反射使用TypeOf和ValueOf函数从接口中获取目标信息</p></li>
<li><p>反射会将匿名字段作为独立字段</p></li>
<li><p>想要利用反射修改对象状态的前提是<code>interface.data</code>是settable，即pointer-interface</p></li>
<li><p>通过反射可以“动态”调用方法</p></li>
<li><p>一些实例</p>
<ul>
<li><div class="sourceCode" id="cb36"><pre class="sourceCode go"><code class="sourceCode go"><a class="sourceLine" id="cb36-1" title="1">  <span class="kw">func</span> main()  {</a>
<a class="sourceLine" id="cb36-2" title="2">      x := <span class="dv">123</span></a>
<a class="sourceLine" id="cb36-3" title="3">      v := reflect.ValueOf(&amp;x)</a>
<a class="sourceLine" id="cb36-4" title="4">      v.Elem().SetInt(<span class="dv">999</span>)  <span class="co">//通过elem来获取的value值</span></a>
<a class="sourceLine" id="cb36-5" title="5">      fmt.Print(x)</a>
<a class="sourceLine" id="cb36-6" title="6">  }</a></code></pre></div></li>
<li><div class="sourceCode" id="cb37"><pre class="sourceCode go"><code class="sourceCode go"><a class="sourceLine" id="cb37-1" title="1">  <span class="kw">type</span> User <span class="kw">struct</span> {</a>
<a class="sourceLine" id="cb37-2" title="2">      Id,Age <span class="dt">int</span></a>
<a class="sourceLine" id="cb37-3" title="3">      Name <span class="dt">string</span></a>
<a class="sourceLine" id="cb37-4" title="4">  }</a>
<a class="sourceLine" id="cb37-5" title="5"></a>
<a class="sourceLine" id="cb37-6" title="6">  <span class="kw">func</span> main()  {</a>
<a class="sourceLine" id="cb37-7" title="7">      u := User{<span class="dv">1</span>,<span class="dv">2</span>, <span class="st">&quot;HHHHH&quot;</span>}</a>
<a class="sourceLine" id="cb37-8" title="8">      Set(&amp;u)</a>
<a class="sourceLine" id="cb37-9" title="9">      fmt.Print(u)</a>
<a class="sourceLine" id="cb37-10" title="10">  }</a>
<a class="sourceLine" id="cb37-11" title="11"></a>
<a class="sourceLine" id="cb37-12" title="12">  <span class="kw">func</span> Set(o <span class="kw">interface</span>{})  {</a>
<a class="sourceLine" id="cb37-13" title="13">      v := reflect.ValueOf(o)</a>
<a class="sourceLine" id="cb37-14" title="14"></a>
<a class="sourceLine" id="cb37-15" title="15">      <span class="kw">if</span> v.Kind()  == reflect.Ptr &amp;&amp; !v.Elem().CanSet(){</a>
<a class="sourceLine" id="cb37-16" title="16">          fmt.Println(<span class="st">&quot;不可以被修改&quot;</span>)</a>
<a class="sourceLine" id="cb37-17" title="17">          <span class="kw">return</span></a>
<a class="sourceLine" id="cb37-18" title="18">      }<span class="kw">else</span> {</a>
<a class="sourceLine" id="cb37-19" title="19">          v = v.Elem()</a>
<a class="sourceLine" id="cb37-20" title="20">      }</a>
<a class="sourceLine" id="cb37-21" title="21"></a>
<a class="sourceLine" id="cb37-22" title="22">      f := v.FieldByName(<span class="st">&quot;Name&quot;</span>)</a>
<a class="sourceLine" id="cb37-23" title="23">      <span class="kw">if</span> !f.IsValid(){</a>
<a class="sourceLine" id="cb37-24" title="24">          fmt.Println(<span class="st">&quot;未找到&quot;</span>)</a>
<a class="sourceLine" id="cb37-25" title="25">          <span class="kw">return</span></a>
<a class="sourceLine" id="cb37-26" title="26">      }</a>
<a class="sourceLine" id="cb37-27" title="27"></a>
<a class="sourceLine" id="cb37-28" title="28">      <span class="kw">if</span> f.Kind() == reflect.String{</a>
<a class="sourceLine" id="cb37-29" title="29">          f.SetString(<span class="st">&quot;BYBYBY&quot;</span>)</a>
<a class="sourceLine" id="cb37-30" title="30">      }</a>
<a class="sourceLine" id="cb37-31" title="31"></a>
<a class="sourceLine" id="cb37-32" title="32">      <span class="co">//if f := v.FieldByName(&quot;Name&quot;); f.Kind() == reflect.String{</span></a>
<a class="sourceLine" id="cb37-33" title="33">      <span class="co">//  f.SetString(&quot;BYBYBY&quot;)</span></a>
<a class="sourceLine" id="cb37-34" title="34">      <span class="co">//}</span></a>
<a class="sourceLine" id="cb37-35" title="35">  } </a></code></pre></div></li>
<li><div class="sourceCode" id="cb38"><pre class="sourceCode go"><code class="sourceCode go"><a class="sourceLine" id="cb38-1" title="1">  <span class="kw">type</span> User <span class="kw">struct</span> {</a>
<a class="sourceLine" id="cb38-2" title="2">      Id,Age <span class="dt">int</span></a>
<a class="sourceLine" id="cb38-3" title="3">      Name <span class="dt">string</span></a>
<a class="sourceLine" id="cb38-4" title="4">  }</a>
<a class="sourceLine" id="cb38-5" title="5"></a>
<a class="sourceLine" id="cb38-6" title="6">  <span class="kw">func</span> (u User)Hello(name <span class="dt">string</span>)  {</a>
<a class="sourceLine" id="cb38-7" title="7">      fmt.Println(name, u.Name)</a>
<a class="sourceLine" id="cb38-8" title="8">  }</a>
<a class="sourceLine" id="cb38-9" title="9"></a>
<a class="sourceLine" id="cb38-10" title="10">  <span class="kw">func</span> main()  {</a>
<a class="sourceLine" id="cb38-11" title="11">      u := User{<span class="dv">1</span>,<span class="dv">2</span>, <span class="st">&quot;OK&quot;</span>}</a>
<a class="sourceLine" id="cb38-12" title="12">      u.Hello(<span class="st">&quot;Joe&quot;</span>)</a>
<a class="sourceLine" id="cb38-13" title="13"></a>
<a class="sourceLine" id="cb38-14" title="14">      v := reflect.ValueOf(u)</a>
<a class="sourceLine" id="cb38-15" title="15">      mv := v.MethodByName(<span class="st">&quot;Hello&quot;</span>)</a>
<a class="sourceLine" id="cb38-16" title="16"></a>
<a class="sourceLine" id="cb38-17" title="17">      args := []reflect.Value{reflect.ValueOf(<span class="st">&quot;Joe&quot;</span>)}</a>
<a class="sourceLine" id="cb38-18" title="18">      mv.Call(args)</a>
<a class="sourceLine" id="cb38-19" title="19"></a>
<a class="sourceLine" id="cb38-20" title="20">  }</a></code></pre></div></li>
</ul></li>
</ul>
<h4 id="并发concurrency">并发concurrency</h4>
<ul>
<li><p>最简单的实例</p>
<ul>
<li><div class="sourceCode" id="cb39"><pre class="sourceCode go"><code class="sourceCode go"><a class="sourceLine" id="cb39-1" title="1">  <span class="kw">func</span> main()  {</a>
<a class="sourceLine" id="cb39-2" title="2">      <span class="kw">go</span> Go()</a>
<a class="sourceLine" id="cb39-3" title="3">      time.Sleep(time.Second) <span class="co">// 使用常量避免单位导致的错误</span></a>
<a class="sourceLine" id="cb39-4" title="4">  }</a>
<a class="sourceLine" id="cb39-5" title="5"></a>
<a class="sourceLine" id="cb39-6" title="6">  <span class="kw">func</span> Go()  {</a>
<a class="sourceLine" id="cb39-7" title="7">      fmt.Println(<span class="st">&quot;gogogo&quot;</span>)</a>
<a class="sourceLine" id="cb39-8" title="8">  }</a></code></pre></div></li>
<li><p>goroutine奉行通过通信来共享内存而不是共享内存来通信</p></li>
<li><p>channel</p>
<ul>
<li><p>是goroutine沟通的桥梁，大都是阻塞同步的</p></li>
<li><p>通过make创建，close关闭</p></li>
<li><p>可以使用for range来迭代不断的操作channel</p></li>
<li><p>可以设置单向或双向通道</p></li>
<li><p>可以设置缓存大小，在未被填满前不会发生阻塞</p>
<ul>
<li>有缓存是异步的，无缓存是同步的</li>
</ul></li>
<li><p>一些实例</p>
<ul>
<li><div class="sourceCode" id="cb40"><pre class="sourceCode go"><code class="sourceCode go"><a class="sourceLine" id="cb40-1" title="1">  <span class="kw">func</span> main()  {<span class="co">// channel的基础操作</span></a>
<a class="sourceLine" id="cb40-2" title="2">      c := <span class="bu">make</span>(<span class="kw">chan</span> <span class="dt">bool</span>)</a>
<a class="sourceLine" id="cb40-3" title="3">      <span class="kw">go</span> <span class="kw">func</span>(){</a>
<a class="sourceLine" id="cb40-4" title="4">          fmt.Println(<span class="st">&quot;gogogo&quot;</span>)</a>
<a class="sourceLine" id="cb40-5" title="5">          c &lt;- <span class="ot">true</span></a>
<a class="sourceLine" id="cb40-6" title="6">      }()</a>
<a class="sourceLine" id="cb40-7" title="7">      &lt;-c</a>
<a class="sourceLine" id="cb40-8" title="8">  }</a></code></pre></div></li>
<li><div class="sourceCode" id="cb41"><pre class="sourceCode go"><code class="sourceCode go"><a class="sourceLine" id="cb41-1" title="1">  <span class="kw">func</span> main()  {</a>
<a class="sourceLine" id="cb41-2" title="2">      c := <span class="bu">make</span>(<span class="kw">chan</span> <span class="dt">bool</span>)</a>
<a class="sourceLine" id="cb41-3" title="3">      <span class="kw">go</span> <span class="kw">func</span>(){</a>
<a class="sourceLine" id="cb41-4" title="4">          fmt.Println(<span class="st">&quot;gogogo&quot;</span>)</a>
<a class="sourceLine" id="cb41-5" title="5">          c &lt;- <span class="ot">true</span></a>
<a class="sourceLine" id="cb41-6" title="6">          <span class="bu">close</span>(c)<span class="co">// 如果不close会出现死锁</span></a>
<a class="sourceLine" id="cb41-7" title="7">      }()</a>
<a class="sourceLine" id="cb41-8" title="8">      <span class="kw">for</span> v := <span class="kw">range</span> c{</a>
<a class="sourceLine" id="cb41-9" title="9">          fmt.Println(v)</a>
<a class="sourceLine" id="cb41-10" title="10">      }</a>
<a class="sourceLine" id="cb41-11" title="11">  }</a></code></pre></div></li>
<li><div class="sourceCode" id="cb42"><pre class="sourceCode go"><code class="sourceCode go"><a class="sourceLine" id="cb42-1" title="1">  <span class="kw">func</span> main()  {</a>
<a class="sourceLine" id="cb42-2" title="2">      runtime.GOMAXPROCS(runtime.NumCPU()) <span class="co">//获得当前CPU的核数并设置</span></a>
<a class="sourceLine" id="cb42-3" title="3">      c := <span class="bu">make</span>(<span class="kw">chan</span> <span class="dt">bool</span>, <span class="dv">10</span>)</a>
<a class="sourceLine" id="cb42-4" title="4">      <span class="kw">for</span> i:= <span class="dv">0</span>;i&lt;<span class="dv">10</span>;i++{</a>
<a class="sourceLine" id="cb42-5" title="5">          <span class="kw">go</span> Go(c, i)</a>
<a class="sourceLine" id="cb42-6" title="6">      }</a>
<a class="sourceLine" id="cb42-7" title="7">      <span class="kw">for</span> i := <span class="dv">0</span>;i&lt;<span class="dv">10</span>;i++ {<span class="co">//当每一个都执行完的时候，这个for循环就执行完了</span></a>
<a class="sourceLine" id="cb42-8" title="8">          &lt;-c</a>
<a class="sourceLine" id="cb42-9" title="9">      }</a>
<a class="sourceLine" id="cb42-10" title="10">  }</a>
<a class="sourceLine" id="cb42-11" title="11"></a>
<a class="sourceLine" id="cb42-12" title="12">  <span class="kw">func</span> Go(c <span class="kw">chan</span> <span class="dt">bool</span>,index <span class="dt">int</span>)  {</a>
<a class="sourceLine" id="cb42-13" title="13">      a := <span class="dv">0</span></a>
<a class="sourceLine" id="cb42-14" title="14">      <span class="kw">for</span> i := <span class="dv">0</span> ;i &lt; <span class="dv">10000000</span>; i++{</a>
<a class="sourceLine" id="cb42-15" title="15">          a += i</a>
<a class="sourceLine" id="cb42-16" title="16">      }</a>
<a class="sourceLine" id="cb42-17" title="17">      fmt.Println(index,a)</a>
<a class="sourceLine" id="cb42-18" title="18">      c &lt;- <span class="ot">true</span></a>
<a class="sourceLine" id="cb42-19" title="19">  }</a></code></pre></div></li>
<li><div class="sourceCode" id="cb43"><pre class="sourceCode go"><code class="sourceCode go"><a class="sourceLine" id="cb43-1" title="1">  <span class="kw">func</span> main()  {</a>
<a class="sourceLine" id="cb43-2" title="2">      <span class="co">/*</span></a>
<a class="sourceLine" id="cb43-3" title="3"><span class="co">      - 每新建一个任务就增加一个任务数</span></a>
<a class="sourceLine" id="cb43-4" title="4"><span class="co">      - 每完成一个任务就减少一个任务数</span></a>
<a class="sourceLine" id="cb43-5" title="5"><span class="co">      - main函数中等待任务数为0</span></a>
<a class="sourceLine" id="cb43-6" title="6"><span class="co">       */</span></a>
<a class="sourceLine" id="cb43-7" title="7">      runtime.GOMAXPROCS(runtime.NumCPU()) <span class="co">//获得当前CPU的核数并设置</span></a>
<a class="sourceLine" id="cb43-8" title="8">      wg := sync.WaitGroup{}</a>
<a class="sourceLine" id="cb43-9" title="9">      <span class="kw">for</span> i:= <span class="dv">0</span>;i&lt;<span class="dv">10</span>;i++{</a>
<a class="sourceLine" id="cb43-10" title="10">          <span class="kw">go</span> Go(&amp;wg, i)</a>
<a class="sourceLine" id="cb43-11" title="11">          wg.Add(<span class="dv">1</span>)</a>
<a class="sourceLine" id="cb43-12" title="12">      }</a>
<a class="sourceLine" id="cb43-13" title="13">      wg.Wait()</a>
<a class="sourceLine" id="cb43-14" title="14">  }</a>
<a class="sourceLine" id="cb43-15" title="15"></a>
<a class="sourceLine" id="cb43-16" title="16">  <span class="kw">func</span> Go(wg *sync.WaitGroup,index <span class="dt">int</span>)  {</a>
<a class="sourceLine" id="cb43-17" title="17">      a := <span class="dv">0</span></a>
<a class="sourceLine" id="cb43-18" title="18">      <span class="kw">for</span> i := <span class="dv">0</span> ;i &lt; <span class="dv">10000000</span>; i++{</a>
<a class="sourceLine" id="cb43-19" title="19">          a += i</a>
<a class="sourceLine" id="cb43-20" title="20">      }</a>
<a class="sourceLine" id="cb43-21" title="21">      fmt.Println(index,a)</a>
<a class="sourceLine" id="cb43-22" title="22">      wg.Done()</a>
<a class="sourceLine" id="cb43-23" title="23">  }</a></code></pre></div></li>
<li></li>
</ul></li>
</ul></li>
<li><p>select</p>
<ul>
<li><p>可处理一个或多个channel的发送与接收</p></li>
<li><p>同时有多个可用的channel时按随机顺序处理</p></li>
<li><p>可用空的select来阻塞main</p></li>
<li><p>可以设置超时</p></li>
<li><p>实例</p>
<ul>
<li><div class="sourceCode" id="cb44"><pre class="sourceCode go"><code class="sourceCode go"><a class="sourceLine" id="cb44-1" title="1">  <span class="kw">func</span> main()  {</a>
<a class="sourceLine" id="cb44-2" title="2">      c1,c2 := <span class="bu">make</span>(<span class="kw">chan</span> <span class="dt">int</span>), <span class="bu">make</span>(<span class="kw">chan</span> <span class="dt">string</span>)</a>
<a class="sourceLine" id="cb44-3" title="3">      o := <span class="bu">make</span>(<span class="kw">chan</span> <span class="dt">bool</span>,<span class="dv">2</span>)</a>
<a class="sourceLine" id="cb44-4" title="4">      <span class="kw">go</span> <span class="kw">func</span>() {</a>
<a class="sourceLine" id="cb44-5" title="5">          <span class="co">//a,b := false,false</span></a>
<a class="sourceLine" id="cb44-6" title="6">          <span class="kw">for</span> {</a>
<a class="sourceLine" id="cb44-7" title="7">              <span class="kw">select</span> {</a>
<a class="sourceLine" id="cb44-8" title="8">              <span class="kw">case</span> v,ok := &lt;-c1:</a>
<a class="sourceLine" id="cb44-9" title="9">                  <span class="kw">if</span> !ok{</a>
<a class="sourceLine" id="cb44-10" title="10">                      <span class="co">//if !a{</span></a>
<a class="sourceLine" id="cb44-11" title="11">                          o &lt;- <span class="ot">true</span></a>
<a class="sourceLine" id="cb44-12" title="12">                          <span class="co">//a = !a</span></a>
<a class="sourceLine" id="cb44-13" title="13">                      <span class="co">//}</span></a>
<a class="sourceLine" id="cb44-14" title="14">                      <span class="kw">break</span></a>
<a class="sourceLine" id="cb44-15" title="15">                  }</a>
<a class="sourceLine" id="cb44-16" title="16">                  fmt.Println(<span class="dv">1</span>,v)</a>
<a class="sourceLine" id="cb44-17" title="17">              <span class="kw">case</span> v,ok := &lt;-c2:</a>
<a class="sourceLine" id="cb44-18" title="18">                  <span class="kw">if</span> !ok{</a>
<a class="sourceLine" id="cb44-19" title="19">                      <span class="co">//if !b{</span></a>
<a class="sourceLine" id="cb44-20" title="20">                          o &lt;- <span class="ot">true</span></a>
<a class="sourceLine" id="cb44-21" title="21">                          <span class="co">//b = !b</span></a>
<a class="sourceLine" id="cb44-22" title="22">                      <span class="co">//}</span></a>
<a class="sourceLine" id="cb44-23" title="23">                      <span class="kw">break</span></a>
<a class="sourceLine" id="cb44-24" title="24">                  }</a>
<a class="sourceLine" id="cb44-25" title="25">                  fmt.Println(<span class="dv">2</span>,v)</a>
<a class="sourceLine" id="cb44-26" title="26">              }</a>
<a class="sourceLine" id="cb44-27" title="27">          }</a>
<a class="sourceLine" id="cb44-28" title="28">      }()</a>
<a class="sourceLine" id="cb44-29" title="29"></a>
<a class="sourceLine" id="cb44-30" title="30">      c1 &lt;- <span class="dv">1</span></a>
<a class="sourceLine" id="cb44-31" title="31">      c2 &lt;- <span class="st">&quot;hello&quot;</span></a>
<a class="sourceLine" id="cb44-32" title="32">      c1 &lt;- <span class="dv">2</span></a>
<a class="sourceLine" id="cb44-33" title="33">      c2 &lt;- <span class="st">&quot;hi&quot;</span></a>
<a class="sourceLine" id="cb44-34" title="34">      <span class="bu">close</span>(c1)</a>
<a class="sourceLine" id="cb44-35" title="35">      <span class="bu">close</span>(c2)</a>
<a class="sourceLine" id="cb44-36" title="36">      <span class="kw">for</span> i:=<span class="dv">0</span> ;i&lt;<span class="dv">2</span> ;i++{</a>
<a class="sourceLine" id="cb44-37" title="37">          &lt;-o</a>
<a class="sourceLine" id="cb44-38" title="38">      }</a>
<a class="sourceLine" id="cb44-39" title="39">  }</a></code></pre></div></li>
<li><div class="sourceCode" id="cb45"><pre class="sourceCode go"><code class="sourceCode go"><a class="sourceLine" id="cb45-1" title="1">  <span class="kw">func</span> main()  {</a>
<a class="sourceLine" id="cb45-2" title="2">      c := <span class="bu">make</span>(<span class="kw">chan</span> <span class="dt">bool</span>)</a>
<a class="sourceLine" id="cb45-3" title="3">      <span class="kw">select</span> {</a>
<a class="sourceLine" id="cb45-4" title="4">      <span class="kw">case</span> v:= &lt;-c:</a>
<a class="sourceLine" id="cb45-5" title="5">          fmt.Println(v)</a>
<a class="sourceLine" id="cb45-6" title="6">      <span class="kw">case</span> &lt;-time.After(<span class="dv">3</span> * time.Second):</a>
<a class="sourceLine" id="cb45-7" title="7">          fmt.Println(<span class="st">&quot;超时&quot;</span>)</a>
<a class="sourceLine" id="cb45-8" title="8">      }</a>
<a class="sourceLine" id="cb45-9" title="9">  }</a></code></pre></div></li>
</ul></li>
</ul></li>
</ul></li>
</ul>
<section class="footnotes" role="doc-endnotes">
<hr />
<ol>
<li id="fn1" role="doc-endnote"><p>没有u的为有符号数，有u的为无符号数<a href="#fnref1" class="footnote-back" role="doc-backlink">↩</a></p></li>
</ol>
</section>
</body>
</html>
